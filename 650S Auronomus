#pragma config(Sensor, in1,    pwrExp,         sensorAnalog)
#pragma config(Sensor, dgtl1,  quadL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  quadR,          sensorQuadEncoder)
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mogoR,     			tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           mogoL,     			tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,          	elevatorL,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           elevatorR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armL,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armR,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveL,        tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           driveR,        tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,           ,             tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard                  !!*//

#pragma systemFile
#pragma DebuggerWindows("debugStream")
#pragma DebuggerWindows("motors")

///////////////////////////////////////////////////////////////////////////////////////
//
// 	Video Reference Source:
//	McCallum Robotics -- VEX for Competition Tutorial | Sensor Programming Part 2
//	YouTube Video: https://www.youtube.com/watch?v=d9d2gCuUybA
//
//	Also Viewable Resources:
//
//	McCallum Robotics -- VEX for Competition Tutorital | Sensor Programming Part 1
//	YouTube Video: https://www.youtube.com/watch?v=9o8rfVUWawQ&t=2s
//
//	McCallum Robotics -- VEX Competition Tutorial | Line-by-Line Autonomous Programming
//	YouTube Video: https://www.youtube.com/watch?v=C64jBTQenYs&t=1103s
//
///////////////////////////////////////////////////////////////////////////////////////

#define PI 3.14159265359

//--------------------------------------------- GLOBAL VARIABLES

	int q1, q2, q3, q4;														// variables to record ditance for testing
	int encoderTicks = 360; 											// number of ticks in a revolution.
																								// QSE = 360. IEM = 627.2 @ 100rpm gearing.
																								// 392 @ 160 rpm gearing
	int wheelDiameter = 4;												// set the wheel diameter in inches
	int MOGOSPEED_STANDARD = 90;
																								// called in encoder functions.
																								// use float and 10.16 for cm.
	int wheelCirc = wheelDiameter * PI;						// circumference of wheel measurement calc.
	int ticksPerInch = encoderTicks / wheelCirc; 	// calc to gen #ticks / inch.

	int varSysTime = nSysTime;


//--------------------------------------------- DRIVE FUNCTIONS: FORWARD
void autoDrive(int speed){
	motor[driveR] = -speed; 								// 'Y' motors RightFront and RightBack
	motor[driveL] = speed;									// 'Y' motors LeftFront and LeftBack
	//motor[] = speed;														// open commmand for programming motors individually
	//motor[] = speed;														// open commmand for programming motors individually
}

/*
void autoDriveTime(int speed, int mSec){
	autoDrive(speed);
	wait1Msec(mSec);
	autoDrive(0);
}
*/

void clearEncoders(){
	SensorValue[quadL] = 0;
	SensorValue[quadR] = 0;
}

void autoDriveDist(int speed, int dist){
	int tickGoal = ticksPerInch * dist;

	/*
	while((abs(SensorValue[quadL])) < tickGoal * 0.6){
		//check for right encoder differences
		int rDiff = abs((SensorValue[quadL])) - abs(SensorValue[quadR]);
		//rMod = 10% speed n the direction of rDiff
		int rMod = sgn(rDiff)*speed*0.1;
	}
	*/

	while(abs(SensorValue[quadL]) < tickGoal){
			autoDrive(speed);
		}
		autoDrive(0);
	}

void raiseMOGO(){
		motor[mogoL] = MOGOSPEED_STANDARD;
		motor[mogoR] = -MOGOSPEED_STANDARD;
		wait1Msec(50);
}

void lowerMOGO(){
		motor[mogoL] = -MOGOSPEED_STANDARD;
		motor[mogoR] = MOGOSPEED_STANDARD;
		wait1Msec(100);
}


//------------------------------------------------------------------	DRIVE FUNCTIONS:TURN FUNCTIONS
//function to turn the robot at a specified speed
//positive speed = turn right, negative speed = turn left

void
autoturn(int speed){
	motor[driveR] = speed;
	motor[driveL] = speed;
	//motor[] = speed;	//open commmand encase of programming motors individually
	//motor[] = speed; 	//open commmand encase of programming motors individually
}

/*
void autoDriveTime(int speed, int mSec){
	autoDrive(speed);
	wait1Msec(mSec);
	autoDrive(0);
}
*/

void autoTurnDist(int speed, int dist){
	int tickGoal = ticksPerInch * dist;
		while(abs(SensorValue[quadL]) < tickGoal)
		{
			autoturn(speed);
		}
	autoturn(0);
}


//+++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++
task main()
{

	clearDebugStream();

	// intial reading
	clearEncoders();

	// lower MOGO
	lowerMOGO();

	q1 = abs(SensorValue(quadL));
	q2 = abs(SensorValue(quadR));
	writeDebugStreamLine("INTIAL READING");
	writeDebugStreamLine("Time: %d", varSysTime);
	writeDebugStreamLine("The value of QuadL is:  %d", q1);
	writeDebugStreamLine("The value of QuadR is:  %d", q2);
	writeDebugStreamLine(" ");

	// straight run command
	// parameters: speed & distance (inches)
	autoDriveDist(60,30); // distance to MOGO target
	clearEncoders();
	autoDriveDist(90,25);
	// command to raise MOGO after retrieve MOGO
	raiseMOGO();

	// straight run report -- move down for collection
	q1 = abs(SensorValue(quadL));
	q2 = abs(SensorValue(quadR));
	writeDebugStreamLine("1ST LEG");
	writeDebugStreamLine("Time: %d", varSysTime);
	writeDebugStreamLine("The value of QuadL is:  %d", q1);
	writeDebugStreamLine("The value of QuadR is:  %d", q2);
	writeDebugStreamLine(" ");

	clearEncoders();

	// turn command with MOGO
	autoTurnDist(100,20);
	clearEncoders();

	// straight run report -- return movement
	//parameters: speed & distance (inches)
	autoDriveDist(60,50); // distance to MOGO target
	clearEncoders();

	// command to lower MOGO
	lowerMOGO();
	clearEncoders();
	// back up for dropping MOGO
	autoDriveDist(-90, 40);


	// // back up for dropping MOGO report block
	q1 = abs(SensorValue(quadL));
	q2 = abs(SensorValue(quadR));
	writeDebugStreamLine("BACK UP");
	writeDebugStreamLine("Time: %d", varSysTime);
	writeDebugStreamLine("The value of QuadL is:  %d", q1);
	writeDebugStreamLine("The value of QuadR is:  %d", q2);
	writeDebugStreamLine(" ");
	clearEncoders();

}
